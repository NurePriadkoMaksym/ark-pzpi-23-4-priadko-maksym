Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра Програмної Інженерії




Звіт
з дисципліни «Аналіз та рефакторинг коду»
Практична робота №1






Виконав:                                                                               Перевірив:
ст. гр. ПЗПІ-23-4                                                                  Сокорчук І. П.
Прядко М. А.






Харків 2025
ХІД РОБОТИ
1 МЕТА
     Метою даної роботи є ознайомлення з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду для мови програмування С++, а також навчитися аналізувати та рефакторити код для покращення його якості.
2 ХІД РОБОТИ
     C++ — це компільована, високопродуктивна мова програмування, яка широко використовується у системному програмуванні, розробці ігор, вбудованих системах та великих програмних продуктах. Щоб забезпечити узгодженість і якість коду, компанія Google створила посібник зі стилю — Google C++ Style Guide. Цей документ визначає правила оформлення коду, які сприяють зручності читання, уніфікації та безпеці.
     
Рекомендація: використовуйте узгоджене іменування
Опис: Під час написання коду, програмісту необхідно правильно називати створені функції, класи, змінні. Правильне іменування дозволить швидко визначити що собою представляє певний відрізок коду:
• Імена змінних та просторів – використовується так званий snake_case, тобто усі літери малі, а слова розділяються нижнім підкресленням
• Імена класів, типів та концептів – Використовується PascalCase, тобто кожне слово починається з великої літери та написані разом.
• Імена констант – всі константи мають літеру «k» на початку, решта слів повинна бути з великої літери, і підкреслення використовуються тільки тоді, коли капіталізація неможлива .
• Імена просторів імен та файлів – тільки малі літери з підкресленнями.
Приклад:
// Поганий приклад
int MyVariable = 0;
void DoSomethingCool();
const int PI = 3.14;
class my_class_name {};
LabWork.cpp
// Гарний приклад
int my_variable = 0;
void DoSomethingCool();
const int kPi = 3.14;
class MyClassName {};
lab_work.cpp
У поганому прикладі імена змінних і класів не відповідають загальноприйнятим стандартам, що ускладнює розуміння їх ролі у коді. У гарному прикладі дотримано правила іменування: змінні використовують snake_case, класи – PascalCase, константи позначені префіксом k. Такий підхід одразу показує призначення елементів коду та полегшує роботу з великими проектами.

Рекомендація: уникайте скорочень і неочевидних назв
Опис: Під час написання коду, імена мають бути зрозумілими й описовими. Не скорочуйте без потреби. Це зробить код більш читабельним та менш плутаючими.
Приклад:
// Поганий приклад
int tmp;
void Proc();

 // Гарний приклад
int temporary_value;
void ProcessInputData();
Пояснення: У поганому прикладі імена tmp та Proc нічого не говорять про призначення змінної чи функції, що може викликати плутанину. У гарному прикладі імена стали описовими, завдяки чому будь-який розробник одразу зрозуміє, для чого призначена змінна та що робить функція, що підвищує читабельність коду.

Рекомендація: Використовуйте пробіли замість табуляції.
Google рекомендує використовувати лише пробіли для відступу та робити відступ на 2 пробіли за один рівень вкладеності. Це правило створене для забезпечення однакового вигляду коду у всіх середовищах розробки, незалежно від налаштувань редактора чи операційної системи.
Використання табуляцій заборонено, оскільки різні інструменти можуть інтерпретувати символ табуляції по-різному, що призводить до зміщення коду, порушення візуальної структури та ускладнення спільної роботи.
Приклад:
// Поганий приклад
if (is_valid) {
     DoSomething();
}

// Гарний приклад
if (is_valid) {
  DoSomething();
}

Рекомендація: дужки завжди на тому ж рядку, що й вираз
Опис: Відкриваюча фігурна дужка { повинна розташовуватись на тому ж рядку, що й заголовок функції, класу чи умовного оператора. Закриваюча дужка } розміщується на окремому рядку, вирівняному за початковим відступом блоку. Такий підхід забезпечує візуальну цілісність конструкції, коли заголовок і тіло логічно пов’язані в один блок. Якщо ж відкриваюча дужка переноситься на новий рядок, код стає “розірваним” і важче простежити структуру програми, особливо при перегляді великих файлів.
Приклад:
// Поганий приклад
if (condition)
{
  DoSomething();
}

// Гарний приклад
if (condition) {
  DoSomething();
}
У поганому прикладі відкриваюча дужка { переноситься на новий рядок, що створює враження “розірваного” коду та ускладнює швидке сприйняття структури блоку. Особливо це помітно у великих функціях або складних умовах, де візуальна цілісність блоку важлива. У гарному прикладі відкриваюча дужка розташована на тому ж рядку, що й заголовок умовного оператора, а закриваюча дужка вирівняна за початковим відступом. Така форма оформлення дозволяє з першого погляду побачити, де починається та закінчується блок, роблячи код більш структурованим та читабельним. Це допомагає уникнути плутанини, коли потрібно швидко зрозуміти логіку виконання коду.

Рекомендація: додавайте коментарі для пояснення логіки, а не очевидних речей
Опис: коментар має пояснювати "чому", а не "що". Використовуйте однорядкові коментарі // для коротких пояснень та блокові коментарі /* ... */ для опису складних ділянок коду.
Приклад:
// Поганий приклад
i++; // інкрементуємо i

// Гарний приклад
// Використовуємо індекс для переходу до наступного елемента списку
i++;

Рекомендація: не використовуйте using namespace std
Опис: така конструкція може призвести до конфліктів імен у великих проектах.
Замість цього використовуйте повні імена або конкретні оголошення using.
Приклад:
// Поганий приклад
using namespace std;
cout << "Hello";

// Гарний приклад
#include <iostream>
using std::cout;
cout << "Hello";
У поганому прикладі використання using namespace std; дозволяє скоротити код, але створює ризик конфліктів імен, особливо у великих проектах або при підключенні сторонніх бібліотек. Якщо з’явиться інша змінна чи функція з однаковою назвою в іншому просторі імен, це може призвести до помилок компіляції або непередбачуваного поведінки. У гарному прикладі використано точне підключення using std::cout;, що дозволяє чітко визначити, яку саме функцію або об’єкт ми використовуємо. Таке оформлення зменшує ймовірність конфліктів та робить код більш передбачуваним і безпечним. Воно також допомагає читачеві одразу розуміти, звідки береться конкретна функція чи змінна. Цей підхід є стандартом для професійної розробки, особливо у великих проектах.

Рекомендація: Використовуйте префіксну форму (++i) операторів інкременту/декременту (++i або --i), оскільки вона ніколи не є менш ефективною і може бути більш ефективною, оскільки не вимагає створення копії значення

Рекомендація: Дотримуйтесь правильного порядку include
Опис:
У Google визначено фіксований порядок підключення файлів: заголовок, який відповідає цьому .cc файлу, cтандартні бібліотеки C, стандартні бібліотеки C++, сторонні бібліотеки, заголовки вашого проекту. Такий порядок спрощує перевірку залежностей та робить код більш структурованим.
// Поганий приклад
#include "my_header.h"
#include <iostream>
#include <vector>
#include <stdio.h>

// Гарний приклад
#include "project/my_header.h"   // відповідний заголовок
#include <stdio.h>               // C headers
#include <iostream>              // C++ STL
#include <vector>
#include "third_party/json/json.h"  // сторонні бібліотеки
#include "project/utils/log.h"      // власні заголовки

Рекомендація: Оголошуйте локальні змінні в найменшій області видимості
Опис:
Оголошуйте змінні якомога ближче до місця їх використання, і завжди ініціалізуйте їх одразу. Це зменшує ймовірність помилок, пов’язаних із неініціалізованими змінними, і робить код легшим для розуміння.
Такий підхід відповідає принципу "declare variables when needed", який підтримує читабельність і знижує ризик побічних ефектів.
Приклад:
// Поганий приклад
int i;
for (i = 0; i < numbers.size(); ++i) {
  int sum = 0;  // занадто далеко від використання
}

// Гарний приклад
for (int i = 0; i < numbers.size(); ++i) {
  int sum = 0;
  sum += numbers[i];
}
У поганому прикладі змінна i оголошена окремо перед циклом, а змінна sum розташована далеко від місця використання, що ускладнює розуміння логіки циклу. Такий підхід підвищує ризик помилок через неініціалізовані змінні або неправильну область видимості. У гарному прикладі змінні оголошуються безпосередньо у циклі, де вони використовуються, що спрощує читання і зменшує можливість помилок. Така організація підкреслює принцип «declare variables when needed» і робить код більш логічним та компактним. Вона також допомагає швидко зрозуміти, для чого потрібні змінні, без пошуку по всьому блоку коду. Це стандарт професійної розробки, який значно покращує підтримуваність коду.

Рекомендація: Використовуйте explicit для однопараметричних конструкторів
Опис:
Конструктори, які приймають один аргумент, слід оголошувати з ключовим словом explicit, щоб уникнути неявних перетворень типів. Це робить код безпечнішим, адже об’єкти не створюються випадково під час передачі аргументів у функції. Також це покращує передбачуваність поведінки програмного коду та знижує ризик логічних помилок.
Приклад:
// Поганий приклад
class StringWrapper {
 public:
  StringWrapper(const char* s) : str_(s) {}
 private:
  std::string str_;
};

void PrintString(StringWrapper s);

PrintString("Hello");  

// Гарний приклад
class StringWrapper {
 public:
  explicit StringWrapper(const char* s) : str_(s) {}
 private:
  std::string str_;
};

void PrintString(StringWrapper s);
PrintString(StringWrapper("Hello"));  
У поганому прикладі конструктор StringWrapper(const char* s) не позначений як explicit, тому можливе неявне перетворення рядка в об’єкт класу при виклику функції PrintString("Hello"). Це може призвести до непередбачуваної поведінки або логічних помилок у великих програмах. У гарному прикладі конструктор оголошено з ключовим словом explicit, що запобігає автоматичному створенню об’єктів під час передачі аргументів. Тепер виклик PrintString(StringWrapper("Hello")) одразу показує намір програміста і робить код більш передбачуваним. Такий підхід підвищує безпеку коду і допомагає уникнути випадкових неявних перетворень. Це особливо важливо у складних проектах, де помилки такого типу важко виявити.

Рекомендація: структура файлів проекту
Опис: структура проєкту має бути логічною. Імена файлів короткі, з нижнього регістру, розділені підкресленням.
Наприклад:
project/
├── base/
│   ├── logging.h
│   └── logging.cc
├── utils/
│   ├── file_reader.h
│   └── file_reader.cc
└── main.cc

3 ВИСНОВКИ
Дотримання стандартів Google C++ Style Guide є ключовим фактором у створенні якісного, підтримуваного та безпечного коду.
Єдиний стиль забезпечує узгодженість у великих командах, покращує читабельність програмного коду та полегшує рефакторинг.
Розробник, який дотримується цих правил, створює більш передбачуваний, ефективний і професійний код, що відповідає сучасним вимогам індустрії.

4 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Google C++ Style Guide. URL: https://google.github.io/styleguide/cppguide.html (дата звернення: 23.10.2025).



ДОДАТОК А
Відеозапис
Посилання на відео: https://youtu.be/uc_bNnM7QfA
Хронологічний опис відеозапису:
00:00 – Вступ 
00:32 – Зміст 
00:42 – Про C++ та Google C++ Style Guide 
01:14 – Правила іменування 
03:01 – Зрозумілі назви 
03:55 – Пробіли замість табуляції 
04:40 – Дужки на тому ж рядку 
05:37 – Коментарі для пояснення логіки 
07:05 – using namespace std 
08:34 – Правильний порядок include 
09:19 – Локальні зміни в найменшій області видимості 
10:36 – explicit для однопараметричних конструкторів 
11:43 – Структура проєкту 
12:05 – Висновки


ДОДАТОК Б
Скріншоти презентації

Рисунок Б.1 - Титульний лист


Рисунок Б.2 - Зміст

Рисунок Б.3 - C++ та Google C++ Style Guide


Рисунок Б.4 - Правила іменування

Рисунок Б.5 - Зрозумілі назви


Рисунок Б.6 - Пробіли замість табуляції



Рисунок Б.7 - Дужки завжди на тому ж рядку, що й вираз


Рисунок Б.8 - Коментарі для пояснення логіки




Рисунок Б.9 - Не використовуйте using namespace std

Рисунок Б.10 - Правильний порядок include


Рисунок Б.11 - Локальні змінні в найменшій області видимості

Рисунок Б.12 - explicit для однопараметричних конструкторів


Рисунок Б.13 - Структура файлів проекту


Рисунок Б.14 - Висновок

Рисунок Б.15 - Використані джерела

2


